defmodule LoanSavingsSystemWeb.UssdController do
    use LoanSavingsSystemWeb, :controller
    alias LoanSavingsSystem.Ussd
    alias LoanSavingsSystem.Ussd.Ussd
    alias LoanSavingsSystem.Accounts.User
    alias LoanSavingsSystem.Companies.Staff
    alias LoanSavingsSystem.Products.Product
    alias LoanSavingsSystem.Loan.LoanProduct
    alias LoanSavingsSystem.Loan.USSDLoanProduct
    alias LoanSavingsSystem.Repo
    alias LoanSavingsSystem.Loan.Loans
    alias LoanSavingsSystem.Loan.LoanCharge
    alias LoanSavingsSystem.Loan.LoanProductCharge
    alias LoanSavingsSystem.Charges.Charge
    alias LoanSavingsSystem.Transactions.Transaction
    alias LoanSavingsSystem.Loan.LoanChargePayment
    alias LoanSavingsSystem.Loan.LoanRepaymentSchedule
    alias LoanSavingsSystem.Ussd.UssdRequest
    require Record
    require Logger
    import Ecto.Query, warn: false


    def index(conn, _params) do
        render(conn, "index.html")
    end


    def initiateUssd(conn, dd) do
        {:ok, body, _conn} = Plug.Conn.read_body(conn)


        Logger.info  "-----------"
        Logger.info  "Debug USSD Controller Starts here"
        Logger.info  body

        query_params = conn.query_params;
        session_id = query_params["SESSION_ID"];
        query_params = conn.query_params;
        Logger.info  Jason.encode!(query_params)
        mobile_number = query_params["MOBILE_NUMBER"]
        text = query_params["USSD_BODY"]

        cmd = query_params["SERVICE_KEY"]
        orginal_short_code = cmd
        Logger.info cmd

        cmd = if (String.equivalent?(cmd, "254*540")) do

            Logger.info "temporary ussd code"
            cmd = "*778#";
            cmd
        else
            text
        end


        query = from cl in LoanSavingsSystem.SystemSetting.ClientTelco, where: (cl.ussdShortCode== ^cmd), select: cl
            clientTelco = Repo.one(query);

        query = from au in UssdRequest, where: au.mobile_number == ^mobile_number and au.session_id == ^session_id, select: au
        ussdRequests = Repo.all(query);

        text = if (Enum.count(ussdRequests) == 0) do

            text = text <> "*";

            Logger.info  "No Ussd Requests"
            Logger.info  text

            ussdRequest = %UssdRequest{}
            ussdRequest = %UssdRequest{mobile_number: mobile_number, request_data: text, session_id: session_id, session_ended: 0}
            case Repo.insert(ussdRequest) do
                {:ok, ussdRequest} ->
                    query = from au in UssdRequest, where: au.mobile_number == ^mobile_number and au.session_id == ^session_id, select: au
                    ussdRequest = Repo.one(query);
                    ussdRequest.request_data
                {:error, changeset} ->
                    Logger.info("Fail")
                    nil;
            end
        else

            Logger.info  "Ussd Requests Exist"

            Logger.info  text

            text = String.trim_leading(text, "*");
            ussdRequest = Enum.at(ussdRequests, 0);

            Logger.info ussdRequest.request_data
			reqdat = ussdRequest.request_data;

            reqdat = String.trim_trailing(reqdat, " ")

            text = reqdat <> text <> "*";

            text = String.replace(text, "*B*", "*b*")
            Logger.info  text


            attrs = %{request_data: text}

            ussdRequest
            |> UssdRequest.changesetForUpdate(attrs)
            |> Repo.update()

            text
        end


        Logger.info "Text===========>";
        Logger.info text;


        if(is_nil(text)) do
            #response = %{
            #    Message: "Technical issues experienced. Press\n\nb. Back\n",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA2"
            #}

			response = "Technical issues experienced. Press\n\nb. Back\n"
            send_response(conn, response)
        else
            clientId = clientTelco.clientId
            Logger.info clientId;
            query = from cl in LoanSavingsSystem.Client.Clients, where: cl.id == ^clientId, select: cl
                client = Repo.one(query);
                clientName = client.clientName
                Logger.info Jason.encode!(client.id)


            query = from au in LoanSavingsSystem.Accounts.User, where: au.username == ^mobile_number, select: au
            appusers = Repo.all(query)
            Logger.info  Enum.count(appusers)



            Logger.info  "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
            tempText = text;
            Logger.info tempText
            text = if String.ends_with?(tempText, "*b*") do
                tempText = "*788#*";

            else
                b_located = String.contains?(tempText, "*b*")
                text = if b_located == true do

                    tempCheckMenu = String.split(tempText, "*b*")
                    Logger.info tempCheckMenu
                    tempCheckMenuFirst = Enum.at(tempCheckMenu, 0);
                    Logger.info tempCheckMenuFirst
                    tempCheckMenuLength = Enum.count(tempCheckMenu);
                    Logger.info tempCheckMenuLength

                    text = if Enum.count(tempCheckMenu) > 1 do
                        Logger.info "tempCheckMenuLast"
                        tempCheckMenuLast = Enum.at(tempCheckMenu, tempCheckMenuLength-1);
                        Logger.info tempCheckMenuLast
                        text = if String.length(tempCheckMenuLast) > 0 do
                              strlen_ = String.length(tempCheckMenuLast) - 1;
                              tempCheckMenuLast = String.slice(tempCheckMenuLast, 0, strlen_);
                              tempText = "*788#*#{tempCheckMenuLast}*"
                        else
                            text

                        end
                    end
                else
                  b_located = String.contains?(tempText, "*0*")
                  text = if b_located == true do

                      text = false
                  else
                      text

                  end


                end
            end


            Logger.info("!!!!!!!")
            Logger.info(text);


			if(text) do
				if (Enum.count(appusers)>0) do
					Logger.info("==2222=================")
					Logger.info Jason.encode!(client.id)
					Logger.info text
					query = from au in UssdRequest, where: au.mobile_number == ^mobile_number and au.session_id == ^session_id, select: au
					ussdRequests = Repo.all(query);
					ussdRequest = Enum.at(ussdRequests, 0);
					Logger.info (Enum.count(ussdRequests));

					if(ussdRequest.is_logged_in != 1) do
						request_user_password(conn, mobile_number, cmd, text, ussdRequests, "Welcome to MFZ Zipake Savings\n\nPlease enter your 4 digit Pin", client, clientTelco);
					else
						welcome_menu(conn, mobile_number, cmd, text, client, clientTelco)
					end
				else
					Logger.info(cmd)
					Logger.info(mobile_number)


					Logger.info("short_code...")
					Logger.info(cmd)
					Logger.info("text...")
					Logger.info(text)

					if text do
                        if(text == "254*") do
                            #response = %{
                            #    Message: "Welcome to #{clientName}. \n\nType your first name",
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "CON"
                            #}


							response = "Welcome to #{clientName}. \n\nType your first name"
                            send_response(conn, response)
                        else
                            checkMenu = String.split(text, "*")
                            checkMenuLength = Enum.count(checkMenu)
                            Logger.info(checkMenuLength)

                            case checkMenuLength do
                                3 ->
                                    #response = %{
                                    #    Message: "Welcome to #{clientName}. \n\nType your first name",
                                    #    ClientState: 1,
                                    #    Type: "Response",
                                    #    key: "CON"
                                    #}

									response = "Welcome to #{clientName}. \n\nType your first name"
                                    send_response(conn, response)
                                4 ->
                                    fname = Enum.at(checkMenu, 2)
                                    checkAlpha = String.match?(fname, ~r/^[[:alpha:]]+$/)

                                    case checkAlpha do
                                        true ->
                                            #response = %{
                                            #    Message: "Enter your last name",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Enter your last name"
                                            send_response(conn, response)
                                        false ->
                                            checkMenuSize = Enum.count(checkMenu) - 3;
                                            checkMenuUpd = Enum.slice(checkMenu, 0..checkMenuSize)
                                            IO.inspect checkMenuUpd
                                            IO.inspect checkMenuSize

                                            text = Enum.join(checkMenuUpd, "*");
                                            IO.inspect text
                                            text = text <> "*";
                                            IO.inspect text
                                            attrs = %{request_data: text}
                                            IO.inspect attrs

                                            ussdRequest = Enum.at(ussdRequests, 0);

                                            query = from au in UssdRequest, where: au.id == ^ussdRequest.id, select: au
                                                ussdRequest = Repo.one(query);
                                            IO.inspect ussdRequest
                                            ussdRequest
                                            |> UssdRequest.changesetForUpdate(attrs)
                                            |> Repo.update()

                                            #response = %{
                                            #    Message: "Invalid first name provided. Enter your first name",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Invalid first name provided. Enter your first name"
                                            send_response(conn, response)

                                    end

                                5 ->

                                    lname = Enum.at(checkMenu, 3)
                                    checkAlpha = String.match?(lname, ~r/^[[:alpha:]]+$/)

                                    case checkAlpha do
                                        true ->
                                            #response = %{
                                            #    Message: "Enter your NRC Number",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Enter your NRC Number"
                                            send_response(conn, response)
                                        false ->
                                            checkMenuSize = Enum.count(checkMenu) - 3;
                                            checkMenuUpd = Enum.slice(checkMenu, 0..checkMenuSize)
                                            IO.inspect checkMenuUpd
                                            IO.inspect checkMenuSize

                                            text = Enum.join(checkMenuUpd, "*");
                                            IO.inspect text
                                            text = text <> "*";
                                            IO.inspect text
                                            attrs = %{request_data: text}
                                            IO.inspect attrs

                                            ussdRequest = Enum.at(ussdRequests, 0);

                                            query = from au in UssdRequest, where: au.id == ^ussdRequest.id, select: au
                                                ussdRequest = Repo.one(query);
                                            IO.inspect ussdRequest
                                            ussdRequest
                                            |> UssdRequest.changesetForUpdate(attrs)
                                            |> Repo.update()

                                            #response = %{
                                            #    Message: "Invalid last name provided. Enter your last name",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Invalid last name provided. Enter your last name"
                                            send_response(conn, response)

                                    end

                                6 ->

                                    nrc = Enum.at(checkMenu, 4)
                                    checkAlpha = Regex.match?(~r/([0-9][0-9][0-9][0-9][0-9][0-9])\/([0-9][0-9])\/([0-9])/, nrc)


                                    case checkAlpha do
                                        true ->
                                            #response = %{
                                            #    Message: "Enter a 4-Digit security pin",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Enter a 4-Digit security pin"
                                            send_response(conn, response)
                                        false ->
                                            checkMenuSize = Enum.count(checkMenu) - 3;
                                            checkMenuUpd = Enum.slice(checkMenu, 0..checkMenuSize)
                                            IO.inspect checkMenuUpd
                                            IO.inspect checkMenuSize

                                            text = Enum.join(checkMenuUpd, "*");
                                            IO.inspect text
                                            text = text <> "*";
                                            IO.inspect text
                                            attrs = %{request_data: text}
                                            IO.inspect attrs

                                            ussdRequest = Enum.at(ussdRequests, 0);

                                            query = from au in UssdRequest, where: au.id == ^ussdRequest.id, select: au
                                                ussdRequest = Repo.one(query);
                                            IO.inspect ussdRequest
                                            ussdRequest
                                            |> UssdRequest.changesetForUpdate(attrs)
                                            |> Repo.update()


                                            #response = %{
                                            #    Message: "Invalid NRC provided. Enter your NRC Number",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}


											response = "Invalid NRC provided. Enter your NRC Number"
                                            send_response(conn, response)

                                    end

                                7 ->
                                    pin = Enum.at(checkMenu, 5)
                                    IO.inspect "pin..." <> pin
                                    checkDigits = Regex.match?(~r/^([0-9]{4})+$/, pin)

                                    case checkDigits do
                                        true ->
                                            #response = %{
                                            #    Message: "Retype the 4-Digit security pin again",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Retype the 4-Digit security pin again"
                                            send_response(conn, response)
                                        false ->
                                            IO.inspect "checkMenu"
                                            IO.inspect checkMenu
                                            checkMenuSize = Enum.count(checkMenu) - 3;
                                            checkMenuUpd = Enum.slice(checkMenu, 0..checkMenuSize)
                                            IO.inspect checkMenuUpd
                                            IO.inspect checkMenuSize
                                            #IO.inspect Enum.join(checkMenuUpd, "*");

                                            text = Enum.join(checkMenuUpd, "*");
                                            IO.inspect text
                                            text = text <> "*";
                                            IO.inspect text
                                            attrs = %{request_data: text}
                                            IO.inspect attrs

                                            ussdRequest = Enum.at(ussdRequests, 0);

                                            query = from au in UssdRequest, where: au.id == ^ussdRequest.id, select: au
                                                ussdRequest = Repo.one(query);
                                            IO.inspect ussdRequest
                                            #ussdRequest = Ecto.Changeset.change ussdRequest, request_data: text
                                            #case Repo.update ussdRequest do
                                            #	{:ok, struct} ->
                                            #		IO.inspect ""
                                            #		IO.inspect struct
                                            #		Repo.transaction()

                                            #	{:error, changeset} ->
                                            #		IO.inspect changeset
                                            #end
                                            #UssdRequest.changesetForUpdate(ussdRequest, attrs)
                                            #|> prepare_update(conn, ussdRequest)
                                            #|> Repo.transaction()
                                            ussdRequest
                                            |> UssdRequest.changesetForUpdate(attrs)
                                            |> Repo.update()


                                            #response = %{
                                            #    Message: "Incorrect values provided. Please enter a valid 4-digit security pin",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Incorrect values provided. Please enter a valid 4-digit security pin"
                                            send_response(conn, response)

                                    end


                                8 ->
                                    #password = Enum.at(checkMenu, 2)
                                    #cpassword = Enum.at(checkMenu, 3)

                                    pin = Enum.at(checkMenu, 5)
                                    rpin = Enum.at(checkMenu, 6)
                                    IO.inspect "pin..." <> pin
                                    IO.inspect "rpin..." <> rpin
                                    checkDigits = Regex.match?(~r/^([0-9]{4})+$/, pin)

                                    case checkDigits do
                                        false ->
                                            #response = %{
                                            #    Message: "Retype the 4-Digit security pin again",
                                            #    ClientState: 1,
                                            #    Type: "Response",
                                            #    key: "CON"
                                            #}

											response = "Retype the 4-Digit security pin again"
                                            send_response(conn, response)
                                        true ->
                                            case String.equivalent?(pin, rpin) do
                                                false ->
                                                    #response = %{
                                                    #    Message: "Pin mismatch! The pins you have provided did not match. Enter a valid 4-digit security pin",
                                                    #    ClientState: 1,
                                                    #    Type: "Response",
                                                    #    key: "CON"
                                                    #}

													response = "Pin mismatch! The pins you have provided did not match. Enter a valid 4-digit security pin"
                                                    send_response(conn, response)
                                                true ->
                                                    fname = Enum.at(checkMenu, 2)
                                                    lname = Enum.at(checkMenu, 3)
                                                    nrc = Enum.at(checkMenu, 4)
                                                    pin = Enum.at(checkMenu, 5)
                                                    pinEnc = LoanSavingsSystem.Accounts.User.encrypt_password(pin)
                                                    Logger.info("fname..." <> fname)
                                                    Logger.info("lname..." <> lname)
                                                    Logger.info("nrc..." <> nrc)
                                                    Logger.info("pinEnc..." <> pinEnc)


                                                    clientId = client.id
                                                    appUser = %LoanSavingsSystem.Accounts.User{username: mobile_number, clientId: clientId, status: "ACTIVE", pin: pinEnc}
                                                    case Repo.insert(appUser) do
                                                        {:ok, appUser} ->
                                                            userId = appUser.id
                                                            firstName = Enum.at(checkMenu, 2)
                                                            lastName = Enum.at(checkMenu, 3)
                                                            meansOfIdentificationType = "NRC"
                                                            meansOfIdentificationNumber = Enum.at(checkMenu, 4)

                                                            appUserBioData = %LoanSavingsSystem.Client.UserBioData{firstName: firstName, lastName: lastName, userId: userId, clientId: clientId,
                                                                mobileNumber: mobile_number, meansOfIdentificationType: meansOfIdentificationType,
                                                                meansOfIdentificationNumber: meansOfIdentificationNumber}
                                                            case Repo.insert(appUserBioData) do
                                                                {:ok, appUserBioData} ->
                                                                    status = "ACTIVE"
                                                                    roleType = "INDIVIDUAL"
                                                                    otp = Enum.random(1_000..9_999)
                                                                    otp = "#{otp}"
                                                                    appUserRole = %LoanSavingsSystem.Accounts.UserRole{roleType: roleType, status: status, userId: userId, clientId: clientId, otp: otp}
                                                                    case Repo.insert(appUserRole) do
                                                                        {:ok, appUserRole} ->
                                                                            accountNo = mobile_number
                                                                            accountType = "SAVINGS"
                                                                            accountVersion = clientTelco.accountVersion
                                                                            clientId = client.id
                                                                            currencyDecimals = client.defaultCurrencyDecimals
                                                                            currencyId = client.defaultCurrencyId
                                                                            currencyName = client.defaultCurrencyName
                                                                            status = "ACTIVE"
                                                                            totalCharges = 0.00;
                                                                            totalDeposits = 0.00;
                                                                            totalInterestEarned = 0.00;
                                                                            totalInterestPosted = 0.00;
                                                                            totalPenalties = 0.00;
                                                                            totalTax = 0.00;
                                                                            totalWithdrawals = 0.00;
                                                                            derivedAccountBalance = 0.00;
                                                                            userId = appUser.id;
                                                                            userRoleId = appUserRole.id;


                                                                            account = %LoanSavingsSystem.Accounts.Account{
                                                                                accountNo: accountNo,
                                                                                accountType: accountType,
                                                                                accountVersion: accountVersion,
                                                                                clientId: clientId,
                                                                                currencyDecimals: currencyDecimals,
                                                                                currencyId: currencyId,
                                                                                currencyName: currencyName,
                                                                                status: status,
                                                                                totalCharges: totalCharges,
                                                                                totalDeposits: totalDeposits,
                                                                                totalInterestEarned: totalInterestEarned,
                                                                                totalInterestPosted: totalInterestPosted,
                                                                                totalPenalties: totalPenalties,
                                                                                derivedAccountBalance: derivedAccountBalance,
                                                                                totalTax: totalTax,
                                                                                totalWithdrawals: totalWithdrawals,
                                                                                userId: userId,
                                                                                userRoleId: userRoleId,
                                                                            }
                                                                            case Repo.insert(account) do
                                                                            {:ok, account} ->
                                                                                    #response = %{
                                                                                    #    Message: "Your new #{clientName} account has been setup for you. Press\n\nb. Back\n0. Log Out",
                                                                                    #    ClientState: 1,
                                                                                    #    Type: "Response",
                                                                                    #    key: "BA3"
                                                                                    #}

																					response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                                                                                    send_response(conn, response)


                                                                            {:error, changeset} ->
                                                                                    Logger.info("Fail")
                                                                                    #response = %{
                                                                                    #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                                                                                    #    ClientState: 1,
                                                                                    #    Type: "Response",
                                                                                    #    key: "BA3"
                                                                                    #}

																					response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                                                                                    send_response(conn, response)
                                                                            end
                                                                        {:error, changeset} ->
                                                                            Logger.info("Fail")
                                                                            #response = %{
                                                                            #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                                                                            #    ClientState: 1,
                                                                            #    Type: "Response",
                                                                            #    key: "BA3"
                                                                            #}

																			response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                                                                            send_response(conn, response)
                                                                    end
                                                                {:error, changeset} ->
                                                                    Logger.info("Fail")
                                                                    #response = %{
                                                                    #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                                                                    #    ClientState: 1,
                                                                    #    Type: "Response",
                                                                    #    key: "BA3"
                                                                    #}

																	response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                                                                    send_response(conn, response)
                                                            end


                                                        {:error, changeset} ->
                                                            Logger.info("Fail")
                                                            #response = %{
                                                            #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                                                            #    ClientState: 1,
                                                            #    Type: "Response",
                                                            #    key: "BA3"
                                                            #}

															response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                                                            send_response(conn, response)
                                                    end
                                            end
                                    end

                                end
                            end
					else
						#response = %{
						#	Message: "Invalid input provided",
						#	ClientState: 1,
						#	Type: "Response",
						#	key: "BA1"
						#}
						response = "Invalid input provided"
						send_response(conn, response)
					end
				end
			else
				#response = %{
				#  Message: "Thank you and Good Bye",
				#  ClientState: 1,
				#  Type: "Response",
				#  key: "end"
				#}

				response = "Thank you and Good Bye"
				end_session(ussdRequests, conn, response);
			end
        end

    end


	def end_session(ussdRequests, conn, response) do

		attrs = %{session_ended: 1};
		if(Enum.count(ussdRequests)>0) do
			ussdRequest = Enum.at(ussdRequests, 0);

			ussdRequest
			|> UssdRequest.changesetForUpdate(attrs)
			|> Repo.update()
		end

		send_response(conn, response)
	end

    def handleMakeDepositChoice(conn, mobile_number, cmd, text, checkMenu, client) do
        checkMenuLength = Enum.count(checkMenu)
        defaultCurrency = client.defaultCurrencyId
        valueEntered = Enum.at(checkMenu, (checkMenuLength-2))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}

			response = "BA3"
            send_response(conn, response)
        else
            case checkMenuLength do
                4 ->
                    #response = %{
                    #    Message: "Enter Amount",
                    #    ClientState: 1,
                    #    Type: "Response",
                    #    key: "CON"
                    #}
					response = "Enter Amount"
                    send_response(conn, response)
                5 ->
                    amount = Enum.at(checkMenu, 3)
                    Logger.info "amount #{amount}"
                    query = from au in LoanSavingsSystem.Products.Product,
                        where: (au.minimumPrincipal <= type(^amount, :float) and au.status == "ACTIVE" and au.maximumPrincipal >= type(^amount, :float) and au.currencyId == type(^defaultCurrency, :integer)) ,
                        select: au
                    savingsProducts = Repo.all(query)

                    if Enum.count(savingsProducts) == 0 do
                        #response = %{
                        #    Message: "We do not have a fixed deposit package for the amount provided= ZMW\n\nb. Back\n0. Exit",
                        #    ClientState: 2,
                        #    Type: "Response",
                        #    key: "CON"
                        #}
						response = "We do not have a fixed deposit package for the amount provided= ZMW\n\nb. Back\n0. Exit"
                        send_response(conn, response)
                    else

                        dayOptions = [];
                        dayOptions = for {k, v} <- Enum.with_index(savingsProducts) do
                            #Logger.info (k.id)
                            totalRepayAmount =0.00
                            if Enum.member?(dayOptions, k.defaultPeriod) do

                            else
                                default_rate = k.interest
                                default_period = k.defaultPeriod
                                annual_period = k.yearLengthInDays
                                amt = elem Integer.parse(amount), 0


                                totalRepayments = calculate_maturity_repayments(amt, default_period, default_rate, annual_period, k.interestMode, k.interestType, k.periodType)
                                Logger.info "Test";
                                Logger.info ((totalRepayments));
                                Logger.info ((k.currencyDecimals));

                                totalRepayAmount = Float.ceil(totalRepayments, k.currencyDecimals)
                                #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [{decimals, k.currencyDecimals}])
                                totalRepayAmount = Float.to_string(totalRepayAmount)
                                Logger.info "#{totalRepayAmount}"
                                default_period = :erlang.integer_to_binary(default_period)
                                repay_entry = "#{v+1}. " <> default_period <> " " <> k.periodType <> " gives you " <> k.currencyName <> totalRepayAmount <> "  "
                                Logger.info "#{totalRepayAmount}"
                                dayOptions = dayOptions ++ [repay_entry]
                                Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                                dayOptions
                            end
                        end


                        if (Enum.count(dayOptions)>0) do
                            optionsList = "";
                            optionsList = Enum.join(dayOptions, "\n");

                            Logger.info optionsList
                            msg = "Choose One. \n\nDeposit " <> client.defaultCurrencyName <> amount <> " for:\n" <> optionsList <> "\nb. Back"

                            #response = %{
                            #    Message: msg,
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = msg
                            send_response(conn, response)
                        else
                            #response = %{
                            #    Message: "Deposit Period= ZMW\n\n1. Choose One\n2. Exit\nb. Back",
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = "Deposit Period= ZMW\n\n1. Choose One\n2. Exit\nb. Back"
                            send_response(conn, response)

                        end
                    end

                6 ->
                    Logger.info "ooooooooooooooooooooooooooooo"
                    Logger.info checkMenu
                    selectedIndex = Enum.at(checkMenu, 4)
                    Logger.info selectedIndex
                    selectedIndex = elem Integer.parse(selectedIndex), 0
                    Logger.info selectedIndex
                    Logger.info "<<<<<<"
                    Logger.info selectedIndex
                    amount = Enum.at(checkMenu, 3)
                    Logger.info amount
                    query = from au in LoanSavingsSystem.Products.Product,
                        where: (au.minimumPrincipal <= type(^amount, :float) and au.status == "ACTIVE" and au.maximumPrincipal >= type(^amount, :float) and au.currencyId == type(^defaultCurrency, :integer)) ,
                        select: au
                    savingsProducts = Repo.all(query)

                    savingsProduct = Enum.at(savingsProducts, (selectedIndex - 1));

                    default_rate = savingsProduct.interest
                    default_period = savingsProduct.defaultPeriod
                    annual_period = savingsProduct.yearLengthInDays
                    amt = elem Integer.parse(amount), 0


                    totalRepayments = calculate_maturity_repayments(amt, default_period, default_rate, annual_period, savingsProduct.interestMode, savingsProduct.interestType, savingsProduct.periodType)
                    Logger.info "Test";
                    Logger.info ((totalRepayments));

                    #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [decimals= savingsProduct.currencyDecimals])
                    totalRepayAmount = Float.ceil(totalRepayments, savingsProduct.currencyDecimals)
                    #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [{decimals, savingsProduct.currencyDecimals}])
                    totalRepayAmount = Float.to_string(totalRepayAmount)
                    Logger.info "#{totalRepayAmount}"
                    default_period = :erlang.integer_to_binary(default_period)
                    repay_entry = default_period <> " " <> savingsProduct.periodType <> " gives you " <> savingsProduct.currencyName <> totalRepayAmount <> "  "
                    Logger.info "#{totalRepayAmount}"
                    dayOptions = [];
                    dayOptions = dayOptions ++ [repay_entry]
                    Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"

                    if (Enum.count(dayOptions)>0) do
                        optionsList = "";
                        optionsList = Enum.join(dayOptions, "\n");

                        Logger.info optionsList
                        msg = "Your preferred choice:\n" <> optionsList <> "\n\n1. Confirm\nb. Back"

                        #response = %{
                        #    Message: msg,
                        #    ClientState: 2,
                        #    Type: "Response",
                        #    key: "CON"
                        #}


						response = msg
                        send_response(conn, response)
                    else
                        #response = %{
                        #    Message: "Deposit Period= ZMW\n\n1. Choose One\n2. Exit\nb. Back",
                        #    ClientState: 2,
                        #    Type: "Response",
                        #    key: "CON"
                        #}

						response = "Deposit Period= ZMW\n\n1. Choose One\n2. Exit\nb. Back"
                        send_response(conn, response)

                    end
                7 ->
                    Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                    selectedIndex = Enum.at(checkMenu, 4)
                    Logger.info "selectedIndex..."
                    Logger.info selectedIndex
                    selectedIndex = elem Integer.parse(selectedIndex), 0
                    Logger.info selectedIndex
                    confirmChoice = Enum.at(checkMenu, 5)
                    Logger.info confirmChoice
                    confirmChoice = elem Integer.parse(confirmChoice), 0
                    Logger.info confirmChoice
                    amount = Enum.at(checkMenu, 3)
                    Logger.info amount
                    amount = elem Float.parse(amount), 0
                    Logger.info amount
                    query = from au in LoanSavingsSystem.Products.Product,
                        where: (au.minimumPrincipal <= type(^amount, :float) and au.status == "ACTIVE" and au.maximumPrincipal >= type(^amount, :float) and au.currencyId == type(^defaultCurrency, :integer)) ,
                        select: au
                    savingsProducts = Repo.all(query)
                    if (confirmChoice != 0 && confirmChoice==1) do
                        #Logger.info amount

                        savingsProduct = Enum.at(savingsProducts, (selectedIndex-1));

                        default_rate = savingsProduct.interest
                        default_period = savingsProduct.defaultPeriod
                        annual_period = savingsProduct.yearLengthInDays
                        #amt = elem Integer.parse(amount), 0
                        amt = amount


                        totalRepayments = calculate_maturity_repayments(amt, default_period, default_rate, annual_period, savingsProduct.interestMode, savingsProduct.interestType, savingsProduct.periodType)
                        Logger.info "Test";
                        Logger.info ((totalRepayments));

                        #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [decimals= savingsProduct.currencyDecimals])
                        totalRepayAmount = Float.ceil(totalRepayments, savingsProduct.currencyDecimals)
                        #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [{decimals, savingsProduct.currencyDecimals}])
                        totalRepayAmount = Float.to_string(totalRepayAmount)
                        Logger.info "#{totalRepayAmount}"
                        default_period = :erlang.integer_to_binary(default_period)
                        repay_entry = default_period <> " " <> savingsProduct.periodType <> " gives you " <> savingsProduct.currencyName <> totalRepayAmount <> "  "
                        Logger.info "#{totalRepayAmount}"
                        Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"

                        query = from au in LoanSavingsSystem.Accounts.User,
                            where: (au.username == type(^mobile_number, :string)),
                            select: au
                        appUsers = Repo.all(query);
                        appUser = Enum.at(appUsers, 0);

                        individualRoleType = "INDIVIDUAL"
                        query = from au in LoanSavingsSystem.Accounts.UserRole,
                            where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                            select: au
                        appUserRoles = Repo.all(query);
                        appUserRole = Enum.at(appUserRoles, 0);

                        Logger.info "Twst ........";
                        Logger.info savingsProduct.id;
                        Logger.info "{confirmChoice}";
                        totalCharges = 0.00;

                        query = from au in LoanSavingsSystem.Products.ProductCharge,
                            where: (au.productId == type(^savingsProduct.id, :integer) and au.chargeWhen == "AT DEPOSIT"),
                            select: au
                        productCharges = Repo.all(query);
                        Logger.info "Saving Charges";
                        Logger.info savingsProduct.id
                        Logger.info Enum.count(productCharges);

                        totalCharge = 0.00;

                        totalCharge = if Enum.count(productCharges) > 0 do
                            totalCharge = for x <- 0..(Enum.count(productCharges)-1) do
                                productCharge = Enum.at(productCharges, x);
                                chargeId = productCharge.chargeId
                                Logger.info "%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
                                Logger.info chargeId
                                query = from au in LoanSavingsSystem.Charges.Charge,
                                    where: (au.id == ^chargeId),
                                    select: au
                                charges = Repo.all(query);
                                charge = Enum.at(charges, 0);


                                totalCharge = case charge.chargeType do
                                    "FLAT" ->
                                        totalCharge = totalCharge + charge.chargeAmount
                                        totalCharge
                                    "PERCENTAGE" ->
                                        totalCharge = totalCharge + (charge.chargeAmount*amount/100)
                                        Logger.info "charge...#{charge.chargeAmount}"
                                        Logger.info "amount...#{amount}"
                                        Logger.info "totalCharge...#{totalCharge}"
                                        totalCharge
                                end

                            end
                        end

                        totalCharge = if is_nil(totalCharge) do
                            totalCharge = 0.00
                        else
                            totalCharge = Float.ceil(Enum.sum(totalCharge), savingsProduct.currencyDecimals)
                        end


                        query = from au in LoanSavingsSystem.Accounts.Account,
                            where: (au.userRoleId == type(^appUserRole.id, :integer)),
                            select: au
                        accounts = Repo.all(query);
                        account = Enum.at(accounts, 0);
                        accountId = account.id

                        accruedInterest= 0.00
                        clientId= client.id
                        currency= savingsProduct.currencyName
                        currencyDecimals= savingsProduct.currencyDecimals
                        currencyId= savingsProduct.currencyId

                                Logger.info "%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
                                Logger.info savingsProduct.defaultPeriod

                        endDate = case savingsProduct.periodType do
                            "Days" ->
                                endDate = Date.add(Date.utc_today, savingsProduct.defaultPeriod)
                                endDate
                            "Months" ->
                                endDate = Date.add(Date.utc_today, savingsProduct.defaultPeriod*30)
                                endDate
                            "Years" ->
                                endDate = Date.add(Date.utc_today, savingsProduct.defaultPeriod*savingsProduct.yearLengthInDays)
                                endDate
                        end


                        expectedInterest= Float.ceil((totalRepayments - amount), savingsProduct.currencyDecimals)
                        fixedPeriod= savingsProduct.defaultPeriod
                        fixedPeriodType= savingsProduct.periodType
                        interestRate= savingsProduct.interest
                        interestRateType= savingsProduct.interestType
                        productInterestMode= savingsProduct.interestMode
                        isDivested= false
                        isMatured= false
                        principalAmount= amount
                        productId= savingsProduct.id
                        startDate= Date.utc_today
                        totalAmountPaidOut= 0.00
                        totalDepositCharge= totalCharge
                        totalPenalties= 0.00
                        totalWithdrawalCharge= 0.00
                        userId= appUser.id
                        userRoleId= appUserRole.id
                        yearLengthInDays= savingsProduct.yearLengthInDays

                        fixedDeposit = %LoanSavingsSystem.FixedDeposit.FixedDeposits{
                            accountId: accountId,
                            accruedInterest: accruedInterest,
                            clientId: clientId,
                            currency: currency,
                            currencyDecimals: currencyDecimals,
                            currencyId: currencyDecimals,
                            endDate: endDate,
                            expectedInterest: expectedInterest,
                            fixedPeriod: fixedPeriod,
                            fixedPeriodType: fixedPeriodType,
                            interestRate: interestRate,
                            interestRateType: interestRateType,
                            isDivested: isDivested,
                            isMatured: isMatured,
                            principalAmount: principalAmount,
                            productId: productId,
                            startDate: startDate,
                            totalAmountPaidOut: totalAmountPaidOut,
                            totalDepositCharge: totalDepositCharge,
                            totalPenalties: totalPenalties,
                            totalWithdrawalCharge: totalWithdrawalCharge,
                            userId: userId,
                            userRoleId: userRoleId,
                            yearLengthInDays: yearLengthInDays,
                            productInterestMode: productInterestMode,
                        }
                        fixedDeposit = Repo.insert!(fixedDeposit);


                        Logger.info(Enum.count(productCharges))
                        if Enum.count(productCharges) > 0 do
                            for x <- 0..(Enum.count(productCharges)-1) do
                                productCharge = Enum.at(productCharges, x);
                                #chargeAmount = if(charge.chargeType=="FLAT") do
                                #    chargeAmount = charge
                                #    chargeAmount
                                #else if(charge.chargeType=="PERCENTAGE") do
                                #    chargeAmount =(charge.chargeAmount*amount/100)
                                #    chargeAmount
                                #end

                                query = from au in Charge,
                                    where: (au.id == ^productCharge.chargeId),
                                    select: au
                                charges = Repo.all(query);
                                charge = Enum.at(charges, 0);
                                Logger.info(charge.id)
                                Logger.info(charge.chargeType)

                                chargeAmount = case charge.chargeType do
                                    "FLAT"->
                                        chargeAmount = Float.ceil((charge), savingsProduct.currencyDecimals)
                                        chargeAmount
                                    "PERCENTAGE"->
                                        chargeAmount =Float.ceil((charge.chargeAmount*amount/100), savingsProduct.currencyDecimals)
                                        chargeAmount
                                end

                                accountCharge = %LoanSavingsSystem.Charges.AccountCharge{
                                    accountId: accountId,
                                    chargeId: productCharge.chargeId,
                                    amountCharged: chargeAmount,
                                    isPaid: true,
                                    dateCharged: Date.utc_today,
                                    datePaid: Date.utc_today,
                                    balance: 0.00,
                                    userId: userId
                                }


                                Repo.insert(accountCharge);
                            end
                        end

                        carriedOutByUserId= userId
                        carriedOutByUserRoleId= userRoleId
                        isReversed= false
                        orderRef= Integer.to_string(Enum.random(1_000000000..9_999999999))
                        productId= savingsProduct.id
                        productType= "SAVINGS"
                        referenceNo= Integer.to_string(Enum.random(1_000000000..9_999999999))
                        requestData= nil
                        responseData= nil
                        status= "Success"
                        totalAmount= amount
                        transactionType= "CR"
                        productCurrency= savingsProduct.currencyName


                        transaction = %LoanSavingsSystem.Transactions.Transaction{
                            accountId: accountId,
                            carriedOutByUserId: carriedOutByUserId,
                            carriedOutByUserRoleId: carriedOutByUserRoleId,
                            isReversed: isReversed,
                            orderRef: orderRef,
                            productId: productId,
                            productType: productType,
                            referenceNo: referenceNo,
                            requestData: requestData,
                            responseData: responseData,
                            status: status,
                            totalAmount: totalAmount,
                            transactionType: transactionType,
                            userId: userId,
                            userRoleId: userRoleId
                        };
                        transaction = Repo.insert!(transaction);



                        fixedDepositTransaction = %LoanSavingsSystem.FixedDeposit.FixedDepositTransaction{
                            clientId: client.id,
                            fixedDepositId: fixedDeposit.id,
                            amountDeposited: principalAmount,
                            transactionId: transaction.id,
                            userId: userId,
                            userRoleId: userRoleId
                        };
                        fixedDepositTransaction = Repo.insert!(fixedDepositTransaction);


                        query = from au in LoanSavingsSystem.Accounts.Account,
                            where: (au.userId == type(^userId, :integer) and au.userRoleId == type(^userRoleId, :integer)),
                            select: au
                        userAccounts = Repo.all(query);
                        acc = Enum.at(userAccounts, 0);
                        #acc = Repo.get!(LoanSavingsSystem.Accounts.Account, fixedDeposit.id)

                        acct = LoanSavingsSystem.Accounts.Account.changesetForUpdate(acc,
                        %{
                            accountNo: acc.accountNo,
                            accountType: acc.accountType,
                            accountVersion: acc.accountVersion,
                            clientId: acc.clientId,
                            currencyDecimals: acc.currencyDecimals,
                            currencyId: acc.currencyId,
                            currencyName: acc.currencyName,
                            status: acc.status,
                            totalCharges: acc.totalCharges,
                            totalDeposits: (acc.totalDeposits + principalAmount),
                            totalInterestEarned: acc.totalInterestEarned,
                            totalInterestPosted: acc.totalInterestPosted,
                            totalPenalties: acc.totalPenalties,
                            totalTax: acc.totalTax,
                            totalWithdrawals: acc.totalWithdrawals,
                            userId: acc.userId,
                            userRoleId: acc.userRoleId,
                            DateClosed: nil,
                            accountOfficerUserId: acc.accountOfficerId,
                            blockedByUserId: acc.blockedByUserId,
                            blockedReason: acc.blockedReason,
                            deactivatedReason: acc.deactivatedReason,
                            derivedAccountBalance: acc.derivedAccountBalance,
                            externalId: acc.externalId
                        })

                        Repo.update!(acct)


                        tempTotalAmount = Float.ceil(totalAmount, savingsProduct.currencyDecimals)
                        #totalRepayAmount = :erlang.float_to_binary((totalRepayments), [{decimals, savingsProduct.currencyDecimals}])
                        tempTotalAmount = Float.to_string(tempTotalAmount)
						response = "Your fixed deposit of #{productCurrency}#{tempTotalAmount} was successful. You will earn #{productCurrency}#{fixedDeposit.expectedInterest} after #{fixedDeposit.fixedPeriod} #{fixedDeposit.fixedPeriodType}. \n\nPress\nb. Back\n0. Log Out"

                        send_response_with_header(conn, response)
                        #timer.sleep(2*1000);


                        mobileNumber = appUser.username;
                        IO.inspect mobileNumber;
                        mobileNumberTruncated = String.slice(mobileNumber, 3..11);

                        url = "https://172.27.162.100:7936/mfzipake";
						xml = "<COMMAND><TYPE>PUSHNOTI</TYPE><interfaceId>09375</interfaceId><MSISDN>#{mobileNumberTruncated}</MSISDN><MSISDN2>889001203</MSISDN2><AMOUNT>#{fixedDepositTransaction.amountDeposited}</AMOUNT><BILLERID>889065746</BILLERID><MEMO>Betpawa Deposit</MEMO><MERCHANT_TXN_ID>#{fixedDepositTransaction.id}</MERCHANT_TXN_ID><USERNAME>BETLION</USERNAME><PASSWORD>BET_AUTH</PASSWORD><REFERENCE_NO>#{fixedDepositTransaction.id}</REFERENCE_NO><MESSAGE>Enter Pin To Make Payment</MESSAGE></COMMAND>";
                        IO.inspect "xml"
                        IO.inspect xml
						options = [ssl: [{:versions, [:'tlsv1']}], recv_timeout: 5000];
						header = [{"Content-Type", "application/xml"}];

						case HTTPoison.post(url, xml, header, options) do
							{:error, %HTTPoison.Error{id: nil, reason: reason}} ->
								IO.inspect ">>>>>>>>>>>>>>>>>"
								IO.inspect reason
								response = %{
									Message: "BA3 ",
									ClientState: 1,
									Type: "Response"
								}
								send_resp(conn, :ok, Jason.encode!(response))
							{:ok, struct} ->
								IO.inspect "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
								IO.inspect  (struct)
								t = struct
								|> Map.get(:body)

								IO.inspect t
								response = %{
									Message: "BA3 ",
									ClientState: 1,
									Type: "Response"
								}
                                send_resp(conn, :ok, Jason.encode!(response))
								#j = t
								#	|> xpath(~x"//MESSAGE/text()")
								#IO.inspect j
								#send_resp(conn, :ok, t)
						end

                        #response = %{
                        #    Message: "Your fixed deposit of #{productCurrency}#{totalAmount} was successful. You will earn #{productCurrency}#{fixedDeposit.expectedInterest} after #{fixedDeposit.fixedPeriod} #{fixedDeposit.fixedPeriodType}. \n\nPress\nb. Back\n0. Log Out",
                        #    ClientState: 2,
                        #    Type: "Response",
                        #    key: "BA4"
                        #}



                    else
                        Logger.info("Fail")
                        #response = %{
                        #    Message: "Invalid selection.. Press\n\nb. Back\n0. Log Out",
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "BA3"
                        #}
						response = "Invalid selection.. Press\n\nb. Back\n0. Log Out"
                        send_response(conn, response)
                    end
            end
        end
    end






    def handleDivest(conn, mobile_number, cmd, text, checkMenu, client, clientTelco) do
        checkMenuLength = Enum.count(checkMenu)
        defaultCurrency = client.defaultCurrencyId
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}

			response = "BA3"
            send_response(conn, response)
        else
            case checkMenuLength do
                4 ->
                    query = from au in User,
                        where: (au.username == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);



                    individualRoleType = "INDIVIDUAL"
                    query = from au in LoanSavingsSystem.Accounts.UserRole,
                        where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                        select: au
                    userRoles = Repo.all(query);
                    userRole = Enum.at(userRoles, 0);


                    status = "Disbursed";
                    isMatured = false
                    isDivested = false
                    query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                        where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId == type(^appUser.id, :integer)),
                        select: au
                    fixedDeposits = Repo.all(query);
                    totalBalance = 0.00;

                        Logger.info "=========="
                        Logger.info Enum.count(fixedDeposits)

                    if Enum.count(fixedDeposits)>0 do

                        #acc = Enum.reduce(fixedDeposits, fn x,
                        #    acc -> x.id * acc
                        #end)

                        totals = for x <- 0..(Enum.count(fixedDeposits)-1) do
                            #totalBalance = Enum.each(fixedDeposits, fn(fixedDeposit) ->
                            fixedDeposit = Enum.at(fixedDeposits, x);


                            query = from au in LoanSavingsSystem.Products.Product,
                                where: (au.id == ^fixedDeposit.productId),
                                select: au
                            products = Repo.all(query);
                            product = Enum.at(products, 0);

                            period = 0;
                            days = Date.diff(Date.utc_today, fixedDeposit.startDate);


							query = from au in LoanSavingsSystem.Divestments.DivestmentPackage,
								where: (au.status == "ACTIVE" and au.productId == ^product.id and au.startPeriodDays <= type(^days, :integer) and au.endPeriodDays >= type(^days, :integer)),
								select: au
							divestmentOption = Repo.one(query);

                            ntotals = calculate_maturity_repayments(fixedDeposit.principalAmount, days,
                               divestmentOption.divestmentValuation, fixedDeposit.yearLengthInDays, product.interestMode,
                               product.interestType, fixedDeposit.fixedPeriodType)
							ntotalsAtDueDate = fixedDeposit.principalAmount + fixedDeposit.expectedInterest
							fullValue = Float.ceil(ntotalsAtDueDate, fixedDeposit.currencyDecimals)

                            Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                            Logger.info ntotals
                            endDate = case fixedDeposit.fixedPeriodType do
                                "Days" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod)
                                    endDate
                                "Months" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*30)
                                    endDate
                                "Years" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*fixedDeposit.yearLengthInDays)
                                    endDate
                            end
                            currentValue = Float.ceil(ntotals, fixedDeposit.currencyDecimals)
                            fixedAmount = Float.ceil(fixedDeposit.principalAmount, fixedDeposit.currencyDecimals)
                            id = "#{fixedDeposit.id}";
                            idLen = String.length(id);

                            fixedDepositNumber = String.pad_leading("#{fixedDeposit.id}", (6 - idLen), "0");
                            "#{(x+1)}. Ref ##{fixedDepositNumber}\nFixed Deposit: " <> fixedDeposit.currency <> "#{fixedAmount}\nCurrent Value: " <> fixedDeposit.currency <> "#{currentValue}\nValue At Maturity: " <> fixedDeposit.currency <> "#{fullValue}\nValue Date: #{endDate}\nDeposit Date: #{fixedDeposit.startDate}\n"


                        end


                        Logger.info Enum.count(totals)
                        Logger.info "=========="
                        acctStatement = (Enum.join(totals, "\n");)
                        text = "Select a fixed deposit to divest \n\n" <> acctStatement <> "\n\nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}

						response = text
                        send_response(conn, response)
					else
						text = "You do not have any fixed Deposits to divest\n\nb. Back \n0. End";
						response = text;
						send_response(conn, response)
                    end
                5 ->

                    Logger.info "<<<<==========>>>>"
                    selectedIndex = Enum.at(checkMenu, 3)
                    Logger.info selectedIndex
                    selectedIndex = elem Integer.parse(selectedIndex), 0
                    query = from au in User,
                        where: (au.username == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);



                    individualRoleType = "INDIVIDUAL"
                    query = from au in LoanSavingsSystem.Accounts.UserRole,
                        where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                        select: au
                    userRoles = Repo.all(query);
                    userRole = Enum.at(userRoles, 0);


                    status = "Disbursed";
                    isMatured = false
                    isDivested = false
                    query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                        where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId >= type(^appUser.id, :integer)),
                        select: au
                    fixedDeposits = Repo.all(query);
                    totalBalance = 0.00;

                        Logger.info "=========="
                        Logger.info Enum.count(fixedDeposits)

                    if Enum.count(fixedDeposits)>0 do


                        #totalBalance = Enum.each(fixedDeposits, fn(fixedDeposit) ->
                        fixedDeposit = Enum.at(fixedDeposits, (selectedIndex-1));


                        query = from au in LoanSavingsSystem.Products.Product,
                            where: (au.id == ^fixedDeposit.productId),
                            select: au
                        products = Repo.all(query);
                        product = Enum.at(products, 0);

                        period = 0;
                        days = Date.diff(Date.utc_today, fixedDeposit.startDate)


                        ntotals = calculate_maturity_repayments(fixedDeposit.principalAmount, days,
                           fixedDeposit.interestRate, fixedDeposit.yearLengthInDays, product.interestMode,
                           product.interestType, fixedDeposit.fixedPeriodType)


                        daysAtEnd = Date.diff(Date.utc_today, fixedDeposit.startDate)
                        ntotalsAtDueDate = fixedDeposit.principalAmount + fixedDeposit.expectedInterest

                        Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                        Logger.info ntotals
                        endDate = case fixedDeposit.fixedPeriodType do
                            "Days" ->
                                endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod)
                                endDate
                            "Months" ->
                                endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*30)
                                endDate
                            "Years" ->
                                endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*fixedDeposit.yearLengthInDays)
                                endDate
                        end

                        fullValue = Float.ceil(ntotalsAtDueDate, fixedDeposit.currencyDecimals)
                        currentValue = Float.ceil(ntotals, fixedDeposit.currencyDecimals)
                        fixedAmount = Float.ceil(fixedDeposit.principalAmount, fixedDeposit.currencyDecimals)
                        acctStatement = "Txn Date: #{fixedDeposit.startDate}\nValue Date:#{endDate}\nFixed Deposit:" <> fixedDeposit.currency <> "#{fixedAmount}\n"

                        id = "#{fixedDeposit.id}";
                        idLen = String.length(id);

                        fixedDepositNumber = String.pad_leading("#{fixedDeposit.id}", (6 - idLen), "0");
                        acctStatement = "Ref ##{fixedDepositNumber}\nFixed Deposit: " <> fixedDeposit.currency <> "#{fixedAmount}\nCurrent Value: " <> fixedDeposit.currency <> "#{currentValue}\nValue At Maturity: " <> fixedDeposit.currency <> "#{fullValue}\nValue Date: #{endDate}\nDeposit Date: #{fixedDeposit.startDate}\n"

                        currentDays = Date.diff(Date.utc_today, fixedDeposit.startDate);
                        query = from au in LoanSavingsSystem.Divestments.DivestmentPackage,
                            where: (au.productId == ^fixedDeposit.productId and au.startPeriodDays <= type(^currentDays, :integer) and au.endPeriodDays >= type(^currentDays, :integer)),
                            select: au
                        divestmentPackages = Repo.all(query);
                        if Enum.count(divestmentPackages) == 0 do
                            #response = %{
                            #    Message: "You can not divest this fixed product. Contact our customer support team for more assistance on this",
                            #    ClientState: 1,
                            #    Type: "Response"
                            #}

							response = "You can not divest this fixed product. Contact our customer support team for more assistance on this"
                            send_response(conn, response)
                        else
                            #divestmentPackage = Enum.at(divestmentPackages, 0);
                            #newValuation = calculate_maturity_repayments(fixedDeposit.principalAmount, days,
                            #      fixedDeposit.interestRate, fixedDeposit.yearLengthInDays, product.interestMode,
                            #      product.interestType, fixedDeposit.fixedPeriodType)

                            Logger.info "=========="
                            text = "Your selected fixed deposit:\n\n " <> acctStatement <> "\n1. Confirm\nb. Back \n0. End";
                            #response = %{
                            #    Message: text,
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = text
                            send_response(conn, response)
                        end
                    end
                6 ->
                    #response = %{
                    #    Message: "Enter how much you are withdrawing today.",
                    #    ClientState: 1,
                    #    Type: "Response",
                    #    key: "CON"
                    #}

					response = "Enter how much you are withdrawing today."
                    send_response(conn, response)
                7 ->
                    selectedIndex = Enum.at(checkMenu, 3)
                    selectedIndex = elem Integer.parse(selectedIndex), 0
                    query = from au in User,
                        where: (au.username == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);

                    individualRoleType = "INDIVIDUAL"
                    query = from au in LoanSavingsSystem.Accounts.UserRole,
                        where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                        select: au
                    userRoles = Repo.all(query);
                    userRole = Enum.at(userRoles, 0);


                    status = "Disbursed";
                    isMatured = false
                    isDivested = false
                    query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                        where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId >= type(^appUser.id, :integer)),
                        select: au
                    fixedDeposits = Repo.all(query);
                    fixedDeposit = Enum.at(fixedDeposits, (selectedIndex-1));
                    totalBalance = 0.00;


                    productId = fixedDeposit.productId
                    query = from au in LoanSavingsSystem.Products.Product,
                        where: (au.id == type(^productId, :integer)) ,
                        select: au
                    savingsProducts = Repo.all(query)
                    savingsProduct = Enum.at(savingsProducts, 0)


                    amount = Enum.at(checkMenu, 5)
                    amount = elem Float.parse(amount), 0
                    Logger.info "<<<<<<"
                    Logger.info amount

                    currentDays = Date.diff(Date.utc_today, fixedDeposit.startDate);
                    query = from au in LoanSavingsSystem.Divestments.DivestmentPackage,
                        where: (au.productId == ^fixedDeposit.productId and au.startPeriodDays <= type(^currentDays, :integer) and au.endPeriodDays >= type(^currentDays, :integer)),
                        select: au
                    divestmentPackages = Repo.all(query);
                    divestmentPackage = Enum.at(divestmentPackages, 0);


                    newValuation = calculate_maturity_repayments(amount, currentDays,
                          divestmentPackage.divestmentValuation, fixedDeposit.yearLengthInDays, savingsProduct.interestMode,
                          savingsProduct.interestType, fixedDeposit.fixedPeriodType)
                    newValuation = Float.ceil(newValuation, 2);
                    totalRepayAmount = Float.ceil(newValuation, fixedDeposit.currencyDecimals)
                    totalRepayAmount = Float.to_string(totalRepayAmount)
                    Logger.info "#{totalRepayAmount}"
                    Logger.info "new valuation... #{totalRepayAmount}"


                    reinvestPeriod = fixedDeposit.fixedPeriod
                    balance = (fixedDeposit.principalAmount - amount)
                    reinvestCurrency = savingsProduct.currencyId


                    if balance>0 do
                        query = from au in LoanSavingsSystem.Products.Product,
                            where: (au.minimumPrincipal <= type(^balance, :float) and au.status == "ACTIVE" and au.maximumPrincipal >= type(^balance, :float) and au.defaultPeriod == type(^reinvestPeriod, :integer) and au.currencyId == type(^reinvestCurrency, :integer)) ,
                            select: au
                        reinvestSavingsProducts = Repo.all(query)

                        if Enum.count(reinvestSavingsProducts)== 0 do
                            msg = "You can not divest the sum of the amount. You can only divest the full funds your have deposited. Press\n\nb. Back\n0. Log Out"

                            #response = %{
                            #    Message: msg,
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "BA3"
                            #}

							response = msg
                            send_response(conn, response)
                        else
                            Logger.info Enum.count(reinvestSavingsProducts)
                            reinvestSavingsProduct = Enum.at(reinvestSavingsProducts, 0)
                            reinvestValuationCurrency = reinvestSavingsProduct.currencyName
                            reinvestPeriod = reinvestSavingsProduct.defaultPeriod
                            reinvestPeriodType = reinvestSavingsProduct.periodType

                            reinvestValuation = calculate_maturity_repayments(balance, reinvestPeriod,
                                reinvestSavingsProduct.interest, reinvestSavingsProduct.yearLengthInDays, reinvestSavingsProduct.interestMode,
                                reinvestSavingsProduct.interestType, reinvestSavingsProduct.periodType)
                            reinvestValuation = Float.ceil(reinvestValuation, reinvestSavingsProduct.currencyDecimals)

                            msg = "If you withdraw today you will receive #{fixedDeposit.currency}#{newValuation} on maturity. \nThe balance will be reinvested to give you #{reinvestValuationCurrency}#{reinvestValuation} on #{fixedDeposit.endDate} \n\n1. Confirm\nb. Back"

                            #response = %{
                            #    Message: msg,
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "CON"
                            #}

							response = msg
                            send_response(conn, response)
                        end
                    else
                        msg = "If you withdraw today you will receive #{fixedDeposit.currency}#{newValuation}";
						msg = msg <> "\n\n1. Confirm\nb. Back"

                        #response = %{
                        #    Message: msg,
                        #    ClientState: 2,
                        #    Type: "Response",
                        #    key: "CON"
                        #}

						response = msg
                        send_response(conn, response)
                    end

                8 ->
                    keyEntered = Enum.at(checkMenu, 6)
                    if keyEntered=="1" do
                        selectedIndex = Enum.at(checkMenu, 3)
                        selectedIndex = elem Integer.parse(selectedIndex), 0
                        query = from au in User,
                            where: (au.username == type(^mobile_number, :string)),
                            select: au
                        appUsers = Repo.all(query);
                        appUser = Enum.at(appUsers, 0);

                        individualRoleType = "INDIVIDUAL"
                        query = from au in LoanSavingsSystem.Accounts.UserRole,
                            where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                            select: au
                        userRoles = Repo.all(query);
                        userRole = Enum.at(userRoles, 0);
                        userRoleId = userRole.id


                        status = "Disbursed";
                        isMatured = false
                        isDivested = false
                        query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                            where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId >= type(^appUser.id, :integer)),
                            select: au
                        fixedDeposits = Repo.all(query);
                        fixedDeposit = Enum.at(fixedDeposits, (selectedIndex-1));
                        totalBalance = 0.00;


                        productId = fixedDeposit.productId
                        query = from au in LoanSavingsSystem.Products.Product,
                            where: (au.id == type(^productId, :integer)) ,
                            select: au
                        savingsProducts = Repo.all(query)
                        savingsProduct = Enum.at(savingsProducts, 0)


                        amount = Enum.at(checkMenu, 5)
                        amount = elem Float.parse(amount), 0
                        Logger.info "<<<<<<"
                        Logger.info amount

                        currentDays = Date.diff(Date.utc_today, fixedDeposit.startDate);
                        query = from au in LoanSavingsSystem.Divestments.DivestmentPackage,
                            where: (au.productId == ^fixedDeposit.productId and au.startPeriodDays <= type(^currentDays, :integer) and au.endPeriodDays >= type(^currentDays, :integer)),
                            select: au
                        divestmentPackages = Repo.all(query);
                        divestmentPackage = Enum.at(divestmentPackages, 0);


                        newValuation = calculate_maturity_repayments(amount, currentDays,
                              divestmentPackage.divestmentValuation, fixedDeposit.yearLengthInDays, savingsProduct.interestMode,
                              savingsProduct.interestType, fixedDeposit.fixedPeriodType)
                        accruedInterest = newValuation - amount
                        newValuation = Float.ceil(newValuation, 2);
                        accruedInterest = Float.ceil(accruedInterest, 2);

                        totalRepayAmount = Float.ceil(newValuation, fixedDeposit.currencyDecimals)
                        totalRepayAmount = Float.to_string(totalRepayAmount)
                        Logger.info "#{totalRepayAmount}"
                        Logger.info "new valuation... #{totalRepayAmount}"


                        reinvestPeriod = fixedDeposit.fixedPeriod
                        balance = (fixedDeposit.principalAmount - amount)
                        reinvestCurrency = savingsProduct.currencyId







                        query = from au in LoanSavingsSystem.Accounts.Account,
                            where: (au.userRoleId == type(^userRole.id, :integer)),
                            select: au
                        accounts = Repo.all(query);
                        account = Enum.at(accounts, 0);
                        accountId = account.id
                        userId = appUser.id

                        carriedOutByUserId= userId
                        carriedOutByUserRoleId= userRoleId
                        isReversed= false
                        orderRef= Integer.to_string(Enum.random(1_000000000..9_999999999))
                        productId= savingsProduct.id
                        productType= "SAVINGS"
                        referenceNo= Integer.to_string(Enum.random(1_000000000..9_999999999))
                        requestData= nil
                        responseData= nil
                        status= "Success"
                        totalAmount= amount
                        transactionType= "DR"
                        productCurrency= savingsProduct.currencyName


                        transaction = %LoanSavingsSystem.Transactions.Transaction{
                            accountId: accountId,
                            carriedOutByUserId: carriedOutByUserId,
                            carriedOutByUserRoleId: carriedOutByUserRoleId,
                            isReversed: isReversed,
                            orderRef: orderRef,
                            productId: productId,
                            productType: productType,
                            referenceNo: referenceNo,
                            requestData: requestData,
                            responseData: responseData,
                            status: status,
                            totalAmount: totalAmount,
                            transactionType: transactionType,
                            userId: userId,
                            userRoleId: userRoleId
                        };
                        transaction = Repo.insert!(transaction);


                        divestment = %LoanSavingsSystem.Divestments.Divestment{
                            clientId: client.id,
                            divestAmount: amount,
                            divestmentDate: Date.utc_today,
                            divestmentDayCount: currentDays,
                            divestmentValuation: divestmentPackage.divestmentValuation,
                            fixedDepositId: fixedDeposit.id,
                            fixedPeriod: fixedDeposit.fixedPeriod,
                            interestRate: fixedDeposit.interestRate,
                            interestRateType: fixedDeposit.interestRateType,
                            principalAmount: fixedDeposit.principalAmount,
                            interestAccrued: accruedInterest,
                            userId: userId,
                            userRoleId: userRoleId
                        };
                        divestment = Repo.insert!(divestment);




                        divestmentTransaction = %LoanSavingsSystem.Divestments.DivestmentTransaction{
                            clientId: client.id,
                            amountDivested: amount,
                            divestmentId: divestment.id,
                            interestAccrued: accruedInterest,
                            transactionId: transaction.id,
                            userId: userId,
                            userRoleId: userRoleId
                        };
                        divestmentTransaction = Repo.insert!(divestmentTransaction);


                        fd = Repo.get!(LoanSavingsSystem.FixedDeposit.FixedDeposits, fixedDeposit.id)
                        cs = LoanSavingsSystem.FixedDeposit.FixedDeposits.changeset(fd,
                            %{
                                accountId: fd.accountId, productId: fd.productId, principalAmount: fd.principalAmount, fixedPeriod: fd.fixedPeriod, fixedPeriodType: fd.fixedPeriodType,
                                interestRate: fd.interestRate, interestRateType: fd.interestRateType, expectedInterest: fd.expectedInterest, accruedInterest: fd.accruedInterest,
                                isMatured: fd.isMatured, isDivested: true, divestmentPackageId: divestmentPackage.id, currencyId: fd.currencyId,
                                currency: fd.currency, currencyDecimals: fd.currencyDecimals, yearLengthInDays: fd.yearLengthInDays, totalDepositCharge: fd.totalDepositCharge,
                                totalWithdrawalCharge: fd.totalWithdrawalCharge, totalPenalties: fd.totalPenalties, userRoleId: fd.userRoleId, userId: fd.userId,
                                totalAmountPaidOut: totalAmount, startDate: fd.startDate, endDate: fd.endDate, clientId: fd.clientId, divestmentId: divestment.id,
								productInterestMode: fd.productInterestMode, branchId: fd.branchId,
								divestedInterestRate: divestmentPackage.divestmentValuation, divestedInterestRateType: fixedDeposit.fixedPeriodType,
								amountDivested: amount, divestedInterestAmount: accruedInterest, divestedPeriod: currentDays
                            })
                        Repo.update!(cs)


                        if balance>0 do
                            query = from au in LoanSavingsSystem.Products.Product,
                                where: (au.minimumPrincipal <= type(^balance, :float) and au.status == "ACTIVE" and au.maximumPrincipal >= type(^balance, :float) and au.defaultPeriod == type(^reinvestPeriod, :integer) and au.currencyId == type(^reinvestCurrency, :integer)) ,
                                select: au
                            reinvestSavingsProducts = Repo.all(query)
                            reinvestSavingsProduct = Enum.at(reinvestSavingsProducts, 0)
                            reinvestValuationCurrency = reinvestSavingsProduct.currencyName
                            reinvestPeriod = reinvestSavingsProduct.defaultPeriod
                            reinvestPeriodType = reinvestSavingsProduct.periodType


                            reinvestValuation = calculate_maturity_repayments(balance, reinvestPeriod,
                                  reinvestSavingsProduct.interest, reinvestSavingsProduct.yearLengthInDays, reinvestSavingsProduct.interestMode,
                                  reinvestSavingsProduct.interestType, reinvestSavingsProduct.periodType)
                            reinvestValuation = Float.ceil(reinvestValuation, reinvestSavingsProduct.currencyDecimals)


                            carriedOutByUserId= userId
                            carriedOutByUserRoleId= userRoleId
                            isReversed= false
                            orderRef= Integer.to_string(Enum.random(1_000000000..9_999999999))
                            productId= reinvestSavingsProduct.id
                            productType= "SAVINGS"
                            referenceNo= Integer.to_string(Enum.random(1_000000000..9_999999999))
                            requestData= nil
                            responseData= nil
                            status= "Success"
                            totalAmount= amount
                            transactionType= "CR"
                            productCurrency= reinvestSavingsProduct.currencyName


                            transaction = %LoanSavingsSystem.Transactions.Transaction{
                                accountId: accountId,
                                carriedOutByUserId: carriedOutByUserId,
                                carriedOutByUserRoleId: carriedOutByUserRoleId,
                                isReversed: isReversed,
                                orderRef: orderRef,
                                productId: productId,
                                productType: productType,
                                referenceNo: referenceNo,
                                requestData: requestData,
                                responseData: responseData,
                                status: status,
                                totalAmount: totalAmount,
                                transactionType: transactionType,
                                userId: userId,
                                userRoleId: userRoleId
                            };
                            Repo.insert(transaction);


                            expectedInterest= Float.ceil((reinvestValuation - balance), reinvestSavingsProduct.currencyDecimals)
                            fixedPeriod= reinvestSavingsProduct.defaultPeriod
                            fixedPeriodType= reinvestSavingsProduct.periodType
                            interestRate= reinvestSavingsProduct.interest
                            interestRateType= reinvestSavingsProduct.interestType
                            isDivested= false
                            isMatured= false
                            principalAmount= balance
                            productId= reinvestSavingsProduct.id
                            startDate= fd.startDate
                            totalAmountPaidOut= 0.00
                            totalDepositCharge= 0.00
                            totalPenalties= 0.00
                            totalWithdrawalCharge= 0.00
                            yearLengthInDays= reinvestSavingsProduct.yearLengthInDays
                            accruedInterest = 0.00
                            currencyId = reinvestSavingsProduct.currencyId
                            currencyDecimals = reinvestSavingsProduct.currencyDecimals
                            currency = reinvestSavingsProduct.currencyName
                            endDate = fd.endDate


                            fixedDeposit = %LoanSavingsSystem.FixedDeposit.FixedDeposits{
                                accountId: accountId,
                                accruedInterest: accruedInterest,
                                clientId: client.id,
                                currency: currency,
                                currencyDecimals: currencyDecimals,
                                currencyId: currencyDecimals,
                                endDate: endDate,
                                expectedInterest: expectedInterest,
                                fixedPeriod: fixedPeriod,
                                fixedPeriodType: fixedPeriodType,
                                interestRate: interestRate,
                                interestRateType: interestRateType,
                                isDivested: isDivested,
                                isMatured: isMatured,
                                principalAmount: principalAmount,
                                productId: productId,
                                startDate: startDate,
                                totalAmountPaidOut: totalAmountPaidOut,
                                totalDepositCharge: totalDepositCharge,
                                totalPenalties: totalPenalties,
                                totalWithdrawalCharge: totalWithdrawalCharge,
                                userId: userId,
                                userRoleId: userRoleId,
                                yearLengthInDays: yearLengthInDays
                            }
                            Repo.insert(fixedDeposit);
                            msg = "The sum of #{fixedDeposit.currency}#{newValuation} has been paid into your mobile money account.\n\n The balance of #{reinvestValuationCurrency}#{balance} has been fixed for #{reinvestPeriod}  #{reinvestPeriodType} to yield you #{reinvestValuationCurrency}#{reinvestValuation}\n\nb. Back"

                            #response = %{
                            #    Message: msg,
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = msg
                            send_response(conn, response)
                        else
                            msg = "The sum of #{fixedDeposit.currency}#{newValuation} has been paid into your mobile money account. Thanks\n\n\nb. Back"

                            #response = %{
                            #    Message: msg,
                            #    ClientState: 2,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = msg
                            send_response(conn, response)
                        end



                    else

                        #response = %{
                        #    Message: "Invalid selection.. Press\n\nb. Back\n0. Log Out",
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "BA3"
                        #}
						response = "Invalid selection.. Press\n\nb. Back\n0. Log Out"
                        send_response(conn, response)
                    end
            end
        end
    end




    def calculate_maturity_repayments(amount, period, rate, annual_period, interestMode, interestType, periodType) do
        Logger.info "################"
        Logger.info amount
        #Logger.info period
        #Logger.info "Rate ...#{rate}"
        #Logger.info annual_period
        Logger.info interestType
        Logger.info interestMode
        Logger.info periodType
        Logger.info annual_period

        rate = case interestType do
            "Days" ->
                rate = rate * annual_period
                rate = rate/100
                rate = rate/annual_period
                rate
            "Months" ->
                rate = rate*12
                rate = rate/100
                rate = rate/annual_period
                rate
            "Years" ->
                rate = rate/100
                Logger.info rate
                rate = rate/annual_period
                Logger.info rate
                rate
        end

        Logger.info "+++++++++++++++++"
        Logger.info rate

        totalRepayable = 0.00;
        y = 1;

        case interestMode do
            "FLAT" ->
                incurredInterest = amount * rate * period
                Logger.info "#{amount} * #{rate} * #{period} * "
                Logger.info incurredInterest
                totalPayableAtEnd = incurredInterest + amount;
                totalPayableAtEnd
            "COMPOUND INTEREST" ->
                rate__ = (1+rate);
                number_of_repayments = 1
                raisedVal = :math.pow(rate__, (number_of_repayments))
                Logger.info raisedVal
                a = rate*raisedVal
                b = raisedVal - 1
                c = a/b
                totalPayableInMonthX = amount * ((rate*(raisedVal))/(raisedVal - 1));
                Logger.info totalPayableInMonthX
                #realMonthlyRepayment = amount * (rate) * (1)
                totalPayableInMonthX
        end
    end



    def welcome_menu(conn, mobile_number, cmd, text, client, clientTelco) do
        Logger.info "Welcome menu ======================"
        Logger.info text
        orginal_short_code = cmd
        clientName = client.clientName


        query = from au in LoanSavingsSystem.Accounts.User, where: au.username == ^mobile_number, select: au
        users = Repo.all(query)
        user = Enum.at(users, 0)

        userId = user.id
        query = from au in LoanSavingsSystem.Accounts.UserRole, where: (au.userId == ^userId and au.roleType == "INDIVIDUAL"), select: au
        customers = Repo.all(query)

        query = from pd in Product, select: pd
        products = Repo.all(query)


        Logger.info "customers count"
        Logger.info Enum.count(customers)
        Logger.info "customers count"
        Logger.info "Products count..."
        Logger.info Enum.count(products)
        Logger.info client.id





        if (Enum.count(customers)>0) do

            checkMenu = String.split(text, "\*")
            checkMenuLength = Enum.count(checkMenu)
            Logger.info(checkMenuLength)

            if checkMenuLength==3 do
                #response = %{
                #    Message: "Welome to #{clientName}\n\n1. Make Deposit of choice\n2. Check Balance\n3. SMS Statement\n4. Divest\n5. Terms and Conditions\n0. End",
                #    ClientState: 1,
                #    Type: "Response",
                #    key: "CON"
                #}
				response = "Welcome to #{clientName}\n\n1. Make Deposit of choice\n2. Check Balance\n3. SMS Statement\n4. Withdraw\n5. Terms and Conditions\n0. End"
                send_response(conn, response)
            end
            if checkMenuLength>3 do
                valueEntered = Enum.at(checkMenu, (2))
                Logger.info (valueEntered);
                case valueEntered do
                    "1" ->
                        Logger.info ("handleMakeDepositChoice");
                        handleMakeDepositChoice(conn, mobile_number, cmd, text, checkMenu, client)
                    "2" ->
                        Logger.info ("handleGetSavingsBalance");
                        handleGetSavingsBalance(conn, mobile_number, cmd, text, checkMenu, client, clientTelco)
                    "3" ->
                        Logger.info ("handleGetSMSStatement");
                        handleGetSMSStatement(conn, mobile_number, cmd, text, checkMenu, client, clientTelco)
                    "4" ->
                        Logger.info ("handleGetLoan");
                        handleDivest(conn, mobile_number, cmd, text, checkMenu, client, clientTelco)
                    "5" ->
                        Logger.info ("handleGetLoan");
                        handleTC(conn, mobile_number, cmd, text, checkMenu)
                    "0" ->
                        Logger.info ("handleGetLoan");
                        text = "Thank you and good bye";
						#response = %{
						#	Message: text,
						#	ClientState: 1,
						#	Type: "Response",
						#	key: "END"
						#}
						response = text
						send_response(conn, response)


                end
            end

        else
            handle_new_account(conn, mobile_number, cmd, text, users, client, clientTelco)
        end

    end




    def handleGetSMSStatement(conn, mobile_number, cmd, text, checkMenu, client, clientTelco) do
        checkMenuLength = Enum.count(checkMenu)
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}

			response = "BA3";
            send_response(conn, response)
        else
            case checkMenuLength do
                4 ->
                    query = from au in User,
                        where: (au.username == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);



                    individualRoleType = "INDIVIDUAL"
                    query = from au in LoanSavingsSystem.Accounts.UserRole,
                        where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                        select: au
                    userRoles = Repo.all(query);
                    userRole = Enum.at(userRoles, 0);


                    status = "Disbursed";
                    isMatured = false
                    isDivested = false
                    query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                        where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId >= type(^appUser.id, :integer)),
                        select: au
                    fixedDeposits = Repo.all(query);
                    totalBalance = 0.00;

                        Logger.info "=========="
                        Logger.info Enum.count(fixedDeposits)

                    if Enum.count(fixedDeposits)>0 do

                        #acc = Enum.reduce(fixedDeposits, fn x,
                        #    acc -> x.id * acc
                        #end)

                        totals = for x <- 0..(Enum.count(fixedDeposits)-1) do
                            #totalBalance = Enum.each(fixedDeposits, fn(fixedDeposit) ->
                            fixedDeposit = Enum.at(fixedDeposits, x);


                            query = from au in LoanSavingsSystem.Products.Product,
                                where: (au.id == ^fixedDeposit.productId),
                                select: au
                            products = Repo.all(query);
                            product = Enum.at(products, 0);

                            period = 0;
                            days = Date.diff(Date.utc_today, fixedDeposit.startDate)
                            daysValue = Date.diff(fixedDeposit.endDate, fixedDeposit.startDate)


                            ntotals = calculate_maturity_repayments(fixedDeposit.principalAmount, days,
                               fixedDeposit.interestRate, fixedDeposit.yearLengthInDays, product.interestMode,
                               product.interestType, fixedDeposit.fixedPeriodType)

						    ntotalsAtDueDate = fixedDeposit.principalAmount + fixedDeposit.expectedInterest
							fullValue = Float.ceil(ntotalsAtDueDate, fixedDeposit.currencyDecimals)

                            Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                            Logger.info ntotals
                            endDate = case fixedDeposit.fixedPeriodType do
                                "Days" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod)
                                    endDate
                                "Months" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*30)
                                    endDate
                                "Years" ->
                                    endDate = Date.add(Date.utc_today, fixedDeposit.fixedPeriod*fixedDeposit.yearLengthInDays)
                                    endDate
                            end
                            currentValue = Float.ceil(ntotals, fixedDeposit.currencyDecimals)
                            fixedAmount = Float.ceil(fixedDeposit.principalAmount, fixedDeposit.currencyDecimals)
                            "Fixed Deposit: " <> fixedDeposit.currency <> "#{fixedAmount}\nCurrent Value: " <> fixedDeposit.currency <> "#{currentValue}\nDeposit Date: #{fixedDeposit.startDate}\nValue At Maturity: " <> fixedDeposit.currency <> "#{fullValue}\nValue Date: #{endDate}\n"
                        end


                        Logger.info Enum.count(totals)
                        Logger.info "=========="
                        acctStatement = (Enum.join(totals, "\n");)
                        text = "Total Balance as at today:\n\n" <> acctStatement <> "\n\nPress \nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}
						response = text
                        send_response(conn, response)
                    end
            end
        end

    end


    def handle_new_account(conn, mobile_number, cmd, text, users, client, clientTelco) do
        Logger.info("===================")
        Logger.info(cmd)
        Logger.info(mobile_number)


        Logger.info("short_code...")
        Logger.info(cmd)
        Logger.info("text...")
        Logger.info(text)
        clientId = client.id
        appUser = Enum.at(users, 0)
        userId = appUser.id
        clientName = client.clientName


        if text do
            checkMenu = String.split(text, "\*")
            checkMenuLength = Enum.count(checkMenu)
            Logger.info(checkMenuLength)


            status = "Active"
            roleType = "INDIVIDUAL"
            otp = Enum.random(1_000..9_999)
            otp = Integer.to_string(otp)
            appUserRole = %LoanSavingsSystem.Accounts.UserRole{roleType: roleType, status: status, userId: userId, clientId: clientId, otp: otp}
            case Repo.insert(appUserRole) do
                {:ok, appUserRole} ->
                    accountNo = mobile_number
                    accountType = "SAVINGS"
                    accountVersion = clientTelco.accountVersion
                    clientId = client.id
                    currencyDecimals = client.defaultCurrencyDecimals
                    currencyId = client.defaultCurrencyId
                    currencyName = client.defaultCurrencyName
                    status = "Active"
                    totalCharges = 0.00;
                    totalDeposits = 0.00;
                    totalInterestEarned = 0.00;
                    totalInterestPosted = 0.00;
                    totalPenalties = 0.00;
                    totalTax = 0.00;
                    totalWithdrawals = 0.00;
                    userId = appUser.id;
                    userRoleId = appUserRole.id;


                    account = %LoanSavingsSystem.Accounts.Account{
                        accountNo: accountNo,
                        accountType: accountType,
                        accountVersion: accountVersion,
                        clientId: clientId,
                        currencyDecimals: currencyDecimals,
                        currencyId: currencyId,
                        currencyName: currencyName,
                        status: status,
                        totalCharges: totalCharges,
                        totalDeposits: totalDeposits,
                        totalInterestEarned: totalInterestEarned,
                        totalInterestPosted: totalInterestPosted,
                        totalPenalties: totalPenalties,
                        totalTax: totalTax,
                        totalWithdrawals: totalWithdrawals,
                        userId: userId,
                        userRoleId: userRoleId,
                    }
                    case Repo.insert(account) do
                      {:ok, account} ->
                            #response = %{
                            #    Message: "Your new #{clientName} account has been setup for you. Press\n\nb. Back\n0. Log Out",
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "BA3"
                            #}
							response = "Your new #{clientName} account has been setup for you. Press\n\nb. Back\n0. Log Out"
                            send_response(conn, response)


                      {:error, changeset} ->
                            Logger.info("Fail")
                            #response = %{
                            #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "BA3"
                            #}

							response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                            send_response(conn, response)
                    end
                {:error, changeset} ->
                    Logger.info("Fail")
                    #response = %{
                    #    Message: "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out",
                    #    ClientState: 1,
                    #    Type: "Response",
                    #   key: "BA3"
                    #}

					response = "Your new #{clientName} account could not be setup for you. Press\n\nb. Back\n0. Log Out"
                    send_response(conn, response)
            end
        else
            #response = %{
            #    Message: "Invalid input provided",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA1"
            #}

			response = "Invalid input provided"
            send_response(conn, response)
        end

    end


    def handleTC(conn, mobile_number, cmd, text, checkMenu) do
        checkMenuLength = Enum.count(checkMenu)
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            tempText = text <> "*";
            tempCheckMenu = String.split(tempText, "*b*")
            tempCheckMenuFirst = Enum.at(tempCheckMenu, 0);
            tempCheckMenuLength = Enum.count(tempCheckMenu);
            tempCheckMenuLast = Enum.at(tempCheckMenu, tempCheckMenuLength-1);

            nText = tempCheckMenuLast
            #response = %{
            #    Message: nText,
            #    ClientState: 1,
            #    Type: "Response"
            #}
			response = nText
            send_response(conn, response)
        else
            tc = "Terms & Conditions\n-------------------------\nTo read our Terms and Conditions, click on the link - https://probasepay.com/zipake_terms_conditions.pdf \n\nb= Back\n0= End";
            #response = %{
            #    Message: tc,
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "END"
            #}
			response = tc
            send_response(conn, response);
        end
    end


    def handleGetSavingsBalance(conn, mobile_number, cmd, text, checkMenu, client, clientTelco) do
        checkMenuLength = Enum.count(checkMenu)
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}
			response = "BA3"
            send_response(conn, response)
        else
            case checkMenuLength do
                4 ->
                    query = from au in User,
                        where: (au.username == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);



                    individualRoleType = "INDIVIDUAL"
                    query = from au in LoanSavingsSystem.Accounts.UserRole,
                        where: (au.userId == type(^appUser.id, :integer) and au.roleType == type(^individualRoleType, :string)),
                        select: au
                    userRoles = Repo.all(query);
                    userRole = Enum.at(userRoles, 0);


                    status = "Disbursed";
                    isMatured = false
                    isDivested = false
                    query = from au in LoanSavingsSystem.FixedDeposit.FixedDeposits,
                        where: (au.isMatured == type(^isMatured, :boolean) and au.isDivested == type(^isDivested, :boolean) and au.userId >= type(^appUser.id, :integer)),
                        select: au
                    fixedDeposits = Repo.all(query);
                    totalBalance = 0.00;

                        Logger.info "=========="
                        Logger.info Enum.count(fixedDeposits)

                    if Enum.count(fixedDeposits)>0 do

                        #acc = Enum.reduce(fixedDeposits, fn x,
                        #    acc -> x.id * acc
                        #end)

                        totals = for x <- 0..(Enum.count(fixedDeposits)-1) do
                            #totalBalance = Enum.each(fixedDeposits, fn(fixedDeposit) ->
                            fixedDeposit = Enum.at(fixedDeposits, x);


                            query = from au in LoanSavingsSystem.Products.Product,
                                where: (au.id == ^fixedDeposit.productId),
                                select: au
                            products = Repo.all(query);
                            product = Enum.at(products, 0);

                            period = 0;
                            days = Date.diff(Date.utc_today, fixedDeposit.startDate)


                            ntotals = calculate_maturity_repayments(fixedDeposit.principalAmount, days,
                               fixedDeposit.interestRate, fixedDeposit.yearLengthInDays, product.interestMode,
                               product.interestType, fixedDeposit.fixedPeriodType)
                            Logger.info "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
                            Logger.info ntotals
                            ntotals
                        end


                        Logger.info Enum.count(totals)
                        Logger.info "=========="
                        totalBalance = Float.ceil(Enum.sum(totals), client.defaultCurrencyDecimals)
                        text = "Total Balance as at today is #{client.defaultCurrencyName}#{totalBalance}\n\nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}

						response = text
                        send_response(conn, response)
                    end
            end
        end

    end


    def handleRepayLoanBalance(conn, mobile_number, cmd, text, checkMenu) do
        checkMenuLength = Enum.count(checkMenu)
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}
			response = "BA3"
            send_response(conn, response)
        else
            case checkMenuLength do
                3 ->
                    query = from au in User,
                        where: (au.mobile_number == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);


                    query = from au in Staff,
                        where: (au.id == type(^appUser.staff_id, :integer)),
                        select: au
                    staffs = Repo.all(query);
                    staff = Enum.at(staffs, 0);


                    status = "Disbursed";
                    query = from au in Loans,
                        where: (au.loan_status == type(^status, :string) and au.customer_id == type(^staff.id, :integer)),
                        select: au
                    loans = Repo.all(query);

                    if Enum.count(loans) > 0 do
                        loan = Enum.at(loans, 0);

                        outstandingTotal = loan.principal_outstanding_derived + loan.interest_outstanding_derived + loan.fee_charges_outstanding_derived + loan.penalty_charges_outstanding_derived;
                        Logger.info(outstandingTotal);
                        outstandingTotal = :erlang.float_to_binary(outstandingTotal, [decimals= 2])
                        principal_outstanding_derived = :erlang.float_to_binary(loan.principal_outstanding_derived, [decimals= 2])
                        interest_outstanding_derived = :erlang.float_to_binary(loan.interest_outstanding_derived, [decimals= 2])
                        fee_charges_outstanding_derived = :erlang.float_to_binary(loan.fee_charges_outstanding_derived, [decimals= 2])
                        penalty_charges_outstanding_derived = :erlang.float_to_binary(loan.penalty_charges_outstanding_derived, [decimals= 2])



                        text = "Loan Account ##{loan.loan_identity_number}\n\nOutstanding Balance= #{loan.currency_code}#{outstandingTotal}\n\n1. Pay Balance\nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}
						response = text
                        send_response(conn, response)
                    else
                        text = "You do not have any loans at the moment. Apply for a loan first. Thank you\n\nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}

						response = text
                        send_response(conn, response)
                    end
                4 ->
                    valueEntered = Enum.at(checkMenu, (3))
                    Logger.info (valueEntered);
                    case valueEntered do
                        "1" ->
                            Logger.info ("handleGetLoan");
                            payLoanBalance(conn, mobile_number, cmd, text, checkMenu)


                    end
            end
        end

    end



    def handleAccountStatus(conn, mobile_number, cmd, text, checkMenu) do
        checkMenuLength = Enum.count(checkMenu)
        valueEntered = Enum.at(checkMenu, (checkMenuLength-1))
        Logger.info("handleGetLoan");
        Logger.info(checkMenuLength);
        Logger.info(valueEntered);
        Logger.info(text);
        if valueEntered == "b" do
            #response = %{
            #    Message: "BA3",
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "BA3"
            #}
			response = "BA3"
            send_response(conn, response)
        else
            case checkMenuLength do
                3 ->
                    query = from au in User,
                        where: (au.mobile_number == type(^mobile_number, :string)),
                        select: au
                    appUsers = Repo.all(query);
                    appUser = Enum.at(appUsers, 0);


                    query = from au in Staff,
                        where: (au.id == type(^appUser.staff_id, :integer)),
                        select: au
                    staffs = Repo.all(query);
                    staff = Enum.at(staffs, 0);


                    if appUser.status == "Active" do

                        text = "Your account is active\n\n1. Pay Balance\nb. Back \n0. End";
                        #response = %{
                        #    Message: text,
                        #    ClientState: 1,
                        #    Type: "Response",
                        #    key: "CON"
                        #}
						response = text;
                        send_response(conn, response)
                    else
                         if appUser.status == "Inactive" do

                            text = "Your account is not active\n\n1. Pay Balance\nb. Back \n0. End";
                            #response = %{
                            #    Message: text,
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "CON"
                            #}

							response = text
                            send_response(conn, response)
                        else
                            text = "Your account has been blocked\n\n1. Pay Balance\nb. Back \n0. End";
                            #response = %{
                            #    Message: text,
                            #    ClientState: 1,
                            #    Type: "Response",
                            #    key: "CON"
                            #}
							response = text
                            send_response(conn, response)
                        end
                    end
            end
        end

    end


    def payLoanBalance(conn, mobile_number, cmd, text, checkMenu) do
        query = from au in User,
            where: (au.mobile_number == type(^mobile_number, :string)),
            select: au
        appUsers = Repo.all(query);
        appUser = Enum.at(appUsers, 0);


        query = from au in Staff,
            where: (au.id == type(^appUser.staff_id, :integer)),
            select: au
        staffs = Repo.all(query);
        staff = Enum.at(staffs, 0);


        status = "Disbursed";
        query = from au in Loans,
            where: (au.loan_status == type(^status, :string) and au.customer_id == type(^staff.id, :integer)),
            select: au
        loans = Repo.all(query);
        if Enum.count(loans)>0 do
            loan = Enum.at(loans, 0);

            outstandingTotal = loan.principal_outstanding_derived + loan.interest_outstanding_derived + loan.fee_charges_outstanding_derived + loan.penalty_charges_outstanding_derived;

            principal_outstanding_derived = :erlang.float_to_binary(loan.principal_outstanding_derived, [decimals= 2])
            interest_outstanding_derived = :erlang.float_to_binary(loan.interest_outstanding_derived, [decimals= 2])
            fee_charges_outstanding_derived = :erlang.float_to_binary(loan.fee_charges_outstanding_derived, [decimals= 2])
            penalty_charges_outstanding_derived = :erlang.float_to_binary(loan.penalty_charges_outstanding_derived, [decimals= 2])

            loan_id = loan.id
            is_reversed = false;
            transaction_type_enum = "LOAN REPAYMENT";
            transaction_date = Date.utc_today;
            principal_portion_derived = loan.principal_outstanding_derived;
            interest_portion_derived = loan.interest_outstanding_derived;
            fee_charges_portion_derived = loan.fee_charges_outstanding_derived;
            penalty_charges_portion_derived = loan.penalty_charges_outstanding_derived;
            overpayment_portion_derived = 0.00;
            unrecognized_income_portion = 0.00;
            outstanding_loan_balance_derived = 0.00;
            submitted_on_date = Date.utc_today;
            manually_adjusted_or_reversed = false;
            manually_created_by_userid = nil;
            amount = outstandingTotal;



            Logger.info "Insert Loan Repayment Transaction";
            # loanTransaction = %Transaction{loan_id= loan_id, is_reversed= is_reversed, transaction_type_enum= transaction_type_enum,
            #     transaction_date= transaction_date, amount= amount, principal_portion_derived= principal_portion_derived, interest_portion_derived= interest_portion_derived,
            #     fee_charges_portion_derived= fee_charges_portion_derived,
            #     penalty_charges_portion_derived= penalty_charges_portion_derived, overpayment_portion_derived= overpayment_portion_derived, unrecognized_income_portion= unrecognized_income_portion,
            #     outstanding_loan_balance_derived= outstanding_loan_balance_derived,
            #     submitted_on_date= submitted_on_date, manually_adjusted_or_reversed= manually_adjusted_or_reversed, manually_created_by_userid= manually_created_by_userid}
            # Repo.insert(loanTransaction);


            query = from au in LoanRepaymentSchedule,
                where: (au.loan_id == type(^loan_id, :integer)),
                select: au
            loanRepaymentSchedules = Repo.all(query)
            for {k, v} <- Enum.with_index(loanRepaymentSchedules) do
                loanRepaymentSchedule = Enum.at(loanRepaymentSchedules, v);
                obligations_met_on_date = Date.utc_today;
                completed_derived = loanRepaymentSchedule.principal_amount
                LoanRepaymentSchedule.changeset(loanRepaymentSchedule, %{obligations_met_on_date: obligations_met_on_date, completed_derived: completed_derived})
                    |> prepare_update(conn, loanRepaymentSchedule)
                    |> Repo.transaction()

            end

            closedon_date = Date.utc_today;
            completed_derived = loan.total_outstanding_derived;
            principal_repaid_derived = loan.approved_principal;
            interest_repaid_derived = loan.interest_charged_derived;
            fee_charges_repaid_derived = loan.fee_charges_charged_derived;
            Loans.changeset(loan, %{closedon_date: closedon_date, completed_derived: completed_derived,
                principal_repaid_derived: principal_repaid_derived, interest_repaid_derived: interest_repaid_derived, fee_charges_repaid_derived: fee_charges_repaid_derived
                })
                |> prepare_update(conn, loan)
                |> Repo.transaction()




            text = "Loan ##{loan.loan_identity_number} completely paid. Thank you\n\nb. Back \n0. End";
            #response = %{
            #    Message: text,
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "END"
            #}
			response = text
            send_response(conn, response)
        else
            text = "You do not have any loans. Apply for a loan first Thank you\n\nb. Back \n0. End";
            #response = %{
            #    Message: text,
            #    ClientState: 1,
            #    Type: "Response",
            #    key: "END"
            #}
			response = text
            send_response(conn, response);
        end
    end

    def prepare_update(changeset, conn, object) do
        Ecto.Multi.new()
        |> Ecto.Multi.update(:object, changeset)
    end




    def send_response(conn, response) do
        Logger.info  "Test!"
        Logger.info  Jason.encode!(response)
        #Logger.info response[:Message];
        #send_resp(conn, :ok, Jason.encode!(response))

        #put_resp_header(conn, "Content-type", "text/html; charset=utf-8");
        #put_resp_header(conn, "Freeflow", "FC");
        #send_resp(conn, :ok, response)


        conn
        |> put_status(:ok)
        |> put_resp_header("Freeflow", "FC")
        |> send_resp(:ok, response)


    end



    def send_response_with_header(conn, response) do
        Logger.info  "Test!"
        Logger.info  Jason.encode!(response)
        #Logger.info response[:Message];
        #send_resp(conn, :ok, Jason.encode!(response))
        #put_resp_header(conn, "Content-type", "text/html; charset=utf-8");
        #put_resp_header(conn, "Freeflow", "FB");
        #send_resp(conn, :ok, response)
        conn
        |> put_status(:ok)
        |> put_resp_header("Freeflow", "FB")
        |> send_resp(:ok, response)
    end



	def request_user_password(conn, mobile_number, cmd, text, ussdRequests, passwordRequestMessage, client, clientTelco) do
		Logger.info text
		orginal_short_code = cmd


		activeStatus = "ACTIVE";
		query = from au in LoanSavingsSystem.Accounts.User, where: au.username == ^mobile_number and au.status == ^activeStatus, select: au
		companyStaff = Repo.one(query)

		if(!is_nil(companyStaff)) do
			checkMenu = String.split(text, "\*")
			checkMenuLength = Enum.count(checkMenu)

			Logger.info("[[[[[[]]]]]]")
			Logger.info(checkMenuLength)

			if checkMenuLength==3 do
				#response = %{
				#	Message: passwordRequestMessage,
				#	ClientState: 1,
				#	Type: "Response",
				#	key: "CON"
				#}
				response = passwordRequestMessage

				send_response(conn, response)
			end
			if checkMenuLength>3 do
				valueEntered = Enum.at(checkMenu, (Enum.count(checkMenu)-2))
				Logger.info (valueEntered);
				handle_validate_password(conn, mobile_number, cmd, text, checkMenu, ussdRequests, valueEntered, client, clientTelco)
			end

		else
			#handle_new_account(conn, mobile_number, cmd, text)
			#response = %{
			#	Message: "Invalid profile. An active profile mapped to this number could not be found. \nContact MFZ staff to assist you with reactivating your profile",
			#	ClientState: 1,
			#	Type: "Response",
			#	key: "END"
			#}

			response = "Invalid profile. An active profile mapped to this number could not be found. \nContact MFZ staff to assist you with reactivating your profile";

			send_response(conn, response)
		end
	end

	def handle_validate_password(conn, mobile_number, cmd, text, checkMenu, ussdRequests, valueEntered, client, clientTelco) do

		activeStatus = "ACTIVE";
		query = from au in LoanSavingsSystem.Accounts.User, where: au.username == ^mobile_number, select: au
		loggedInUser = Repo.one(query)


		if(!is_nil(loggedInUser)) do

			if(loggedInUser.status != activeStatus) do
				#response = %{
				#	Message: "Your account is no longer active. Please contact LAXMI to reactivate your account. ",
				#	ClientState: 1,
				#	Type: "Response",
				#	key: "END"
				#}
				response = "Your account is no longer active. Please contact LAXMI to reactivate your account. "
				end_session(ussdRequests, conn, response);
			else
				passwordChecker = Base.encode16(:crypto.hash(:sha512, valueEntered))
				passwordChecker1 = String.trim_trailing(loggedInUser.pin, " ")
				IO.inspect "passwordChecker..."
				IO.inspect passwordChecker
				IO.inspect loggedInUser.pin
				IO.inspect passwordChecker1

				case String.equivalent?(passwordChecker, passwordChecker1) do
					false ->
						if(loggedInUser.password_fail_count>2) do

							attrs = %{password_fail_count: 3, status: "Blocked"}

							loggedInUser
							|> User.changeset(attrs)
							|> Repo.update()
						else

							attrs = %{password_fail_count: (loggedInUser.password_fail_count + 1)}

							loggedInUser
							|> User.changeset(attrs)
							|> Repo.update()
						end


						attrs = %{request_data: "*778#*"}
						ussdRequest = Enum.at(ussdRequests, 0);
						session_id = ussdRequest.session_id;

						ussdRequest
						|> UssdRequest.changeset(attrs)
						|> Repo.update()

						text = "\*778#\*"
						request_user_password(conn, mobile_number, cmd, text, ussdRequests, "Invalid credentials. Please log in again. Your account will be locked if you fail to log in after 3 times", client, clientTelco);

					true ->
						ussdRequest = Enum.at(ussdRequests, 0);
						session_id = ussdRequest.session_id;

						Logger.info (ussdRequest.id);

						{1, [ussdRequest]} =
							from(p in UssdRequest, where: p.id == ^ussdRequest.id, select: p)
							|> Repo.update_all(set: [request_data: "*778#*", is_logged_in: 1]);


						text = "*778#*";
						query = from au in UssdRequest, where: au.mobile_number == ^mobile_number and au.session_id == ^session_id, select: au
						ussdRequests = Repo.all(query);
						welcome_menu(conn, mobile_number, cmd, text, client, clientTelco)
				end
			end

		else

			#response = %{
			#	Message: "Invalid credentials.",
			#	ClientState: 1,
			#	Type: "Response",
			#	key: "END"
			#}
			response = "Invalid credentials."
			end_session(ussdRequests, conn, response);
		end

	end
end
